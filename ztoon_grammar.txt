          
Rules order here is importatn. You can see that "primary" is at the bottom
of the expression grammar. Thus, it has the highet precedence.

Expressions Rules:

expression     -> assignment ;
assignment     -> IDENTIFIER "=" assignment | equality ;
equality       -> comparison ( ( "!=" | "==" ) comparison )* ;
comparison     -> term ( ( ">" | ">=" | "<" | "<=" ) term )* ;
term           -> factor ( ( "-" | "+" ) factor )* ;
factor         -> unary ( ( "/" | "*" | "%" ) unary )* ;
unary          -> ( "!" | "-" ) unary
               | primary ;
cast           -> primary 'as' dataType
               | primary

//datatype is not and expression, it does not affect the precedence.
//I defined it here only for clarity.
datatype       -> "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64"
                  | "f32" | "f64" | "bool" | "str" ;
primary        -> NUMBER | STRING | "true" | "false" | "null"
               | "(" expression ")" | IDENTIFIER ;

Order of statments grammar is also important.
It specifies the precedence of each statment.
Statements Rules:

program        -> declaration* EOF ;
declaration    -> varDecl | stmt ;
varDecl        -> IDENTIFIER ":" datatype ("=" expression)? ";" ;
stmt           -> exprStmt ;
exprStmt       -> expr ;
            
